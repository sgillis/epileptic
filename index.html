<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <html manifest="cache.manifest">
    <title>Sample Media Receiver</title>
    <!--
        Cast APIs
    -->
    <script type="text/javascript" src="//www.gstatic.com/cast/sdk/libs/receiver/2.0.0/cast_receiver.js"></script>

    <style>
        body {
            overflow:hidden;
        }
        .circleBase {
            border-radius: 50%;
            behavior: url(PIE.htc); /* remove if you don't care about IE8 */
        }

        .type1 {
            width: 100px;
            height: 100px;
            background: yellow;
            border: 3px solid red;
        }
        .type2 {
            width: 50px;
            height: 50px;
            background: #ccc;
            border: 3px solid #000;
        }
        .type3 {
            width: 80px;
            height: 80px;
            background: white;
        }

    </style>
</head>
<body>
    <div id="circle" class="circleBase type3"></div>
    <div id="circle" class="circleBase type3"></div>

    <script type="text/javascript">
        "use strict";

        window.castReceiverManager = null;
        window.mediaManager = null;
        window.messageBus = null;
        window.mediaElement = null;
        window.mediaHost = null;
        window.mediaProtocol = null;
        window.mediaPlayer = null;
        window.connectedCastSenders = []; // {senderId:'', channel:obj}

        function changeBackground(color) {
            document.body.style.background = color;
        }

        function changeCircleColor(color) {
            document.getElementById('circle').style.backgroundColor=color;
        }

        window.onload = function() {
            /**
             * Sets the log verbosity level.
             *
             * Debug logging (all messages).
             * DEBUG
             *
             * Verbose logging (sender messages).
             * VERBOSE
             *
             * Info logging (events, general logs).
             * INFO
             *
             * Error logging (errors).
             * ERROR
             *
             * No logging.
             * NONE
             **/
            cast.receiver.logger.setLevelValue(cast.receiver.LoggerLevel.DEBUG);

            window.castReceiverManager = cast.receiver.CastReceiverManager.getInstance();

            /**
             * Called to process 'ready' event. Only called after calling castReceiverManager.start(config) and the
             * system becomes ready to start receiving messages.
             *
             * @param {cast.receiver.CastReceiverManager.Event} event - can be null
             *
             * There is no default handler
             */
            window.castReceiverManager.onReady = function(event) {
                console.log("### Cast Receiver Manager is READY: " + JSON.stringify(event));
            }

            /**
             * If provided, it processes the 'senderconnected' event.
             * Called to process the 'senderconnected' event.
             * @param {cast.receiver.CastReceiverManager.Event} event - can be null
             *
             * There is no default handler
             */
            window.castReceiverManager.onSenderConnected = function(event) {
                console.log("### Cast Receiver Manager - Sender Connected : " + JSON.stringify(event));
            }

            /**
             * If provided, it processes the 'senderdisconnected' event.
             * Called to process the 'senderdisconnected' event.
             * @param {cast.receiver.CastReceiverManager.Event} event - can be null
             *
             * There is no default handler
             */
            window.castReceiverManager.onSenderDisconnected = function(event) {
                console.log("### Cast Receiver Manager - Sender Disconnected : " + JSON.stringify(event));
            }

            /**
             * If provided, it processes the 'systemvolumechanged' event.
             * Called to process the 'systemvolumechanged' event.
             * @param {cast.receiver.CastReceiverManager.Event} event - can be null
             *
             * There is no default handler
             */
            window.castReceiverManager.onSystemVolumeChanged = function(event) {
                console.log("### Cast Receiver Manager - System Volume Changed : " + JSON.stringify(event));
            }

            /**
             * Called to process the 'visibilitychanged' event.
             *
             * Fired when the visibility of the application has changed (for example
             * after a HDMI Input change or when the TV is turned off/on and the cast
             * device is externally powered). Note that this API has the same effect as
             * the webkitvisibilitychange event raised by your document, we provided it
             * as CastReceiverManager API for convenience and to avoid a dependency on a
             * webkit-prefixed event.
             *
             * @param {cast.receiver.CastReceiverManager.Event} event - can be null
             *
             * There is no default handler for this event type.
             */
            window.castReceiverManager.onVisibilityChanged = function(event) {
                console.log("### Cast Receiver Manager - Visibility Changed : " + JSON.stringify(event));

                /** check if visible and pause media if not - add a timer to tear down after a period of time
                   if visibilty does not change back **/
                if (event.data) { // It is visible
                    window.clearTimeout(window.timeout); // Turn off the timeout
                    window.timeout = null;
                } else {
                    window.timeout = window.setTimeout(function(){window.close();}, 10000); // 10 Minute timeout
                }
            }


            /**
             * ALTERNATIVE TO onVisibilityChanged
             *
             * Use this to know when the user switched away from the Cast device input. It depends on the TV
             * Supporting CEC
             **/
            document.addEventListener('webkitvisibilitychange', function(){
                if(document.webkithidden) {
                    window.timeout = window.setTimeout(function(){window.close();}, 10000); // 10 Minute timeout
                } else {
                    window.clearTimeout(window.timeout); // Turn off the timeout
                    window.timeout = null;
                }
            });


            /**
             * Use the messageBus to listen for incoming messages on a virtual channel using a namespace string.
             * Also use messageBus to send messages back to a sender or broadcast a message to all senders.
             * You can check the cast.receiver.CastMessageBus.MessageType that a message bus processes though a call
             * to getMessageType. As well, you get the namespace of a message bus by calling getNamespace()
             */
            window.messageBus = window.castReceiverManager.getCastMessageBus('urn:x-cast:com.google.devrel.custom');
            /**
             * The namespace urn:x-cast:com.google.devrel.custom is used to identify the protocol of showing/hiding
             * the heads up display messages (The messages defined at the beginning of the html).
             *
             * The protocol consists of one string message: show
             * In the case of the message value not being show - the assumed value is hide.
             **/
            window.messageBus.onMessage = function(event) {
                console.log("### Message Bus - Media Message: " + JSON.stringify(event));
                setHudMessage('messageBusMessage', event);

                console.log("### CUSTOM MESSAGE: " + JSON.stringify(event));
                // show/hide messages
                console.log(event['data']);
                if(event['data']==='show') {
                    document.getElementById('messages').style.display = 'block';
                } else if(event['data']==='hide') {
                    document.getElementById('messages').style.display = 'none';
                } else if(event['data']==='red') {
                    changeCircleColor('red');
                } else if(event['data']==='white'){
                    changeCircleColor('white');
                }
            }

            console.log('### Application Loaded. Starting system.');

            /**
             * Application config
             **/
            var appConfig = new cast.receiver.CastReceiverManager.Config();

            /**
             * Text that represents the application status. It should meet
             * internationalization rules as may be displayed by the sender application.
             * @type {string|undefined}
             **/
            appConfig.statusText = 'Ready to play';

            /**
             * Maximum time in seconds before closing an idle
             * sender connection. Setting this value enables a heartbeat message to keep
             * the connection alive. Used to detect unresponsive senders faster than
             * typical TCP timeouts. The minimum value is 5 seconds, there is no upper
             * bound enforced but practically it's minutes before platform TCP timeouts
             * come into play. Default value is 10 seconds.
             * @type {number|undefined}
             **/
            appConfig.maxInactivity = 6000; // 10 minutes for testing, use default 10sec in prod by not setting this value

            /**
             * Initializes the system manager. The application should call this method when
             * it is ready to start receiving messages, typically after registering
             * to listen for the events it is interested on.
             */
            window.castReceiverManager.start(appConfig);
        }
    </script>
</body>
</html>
